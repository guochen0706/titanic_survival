---
title: "Exploring Two Variables"
output: html_document
---

```{r}
library(ggplot2)
library(dplyr)
data(diamonds)
```
Note: 
Your first task is to create a scatterplot of price vs x.
using the ggplot syntax.

```{r scatterplot of price vs x, echo=FALSE}
ggplot(aes(x, price), data = diamonds) +
  geom_point()
```

Note:
Find correlations of price and x, price and y, price and z

```{r Correlations, echo=FALSE}
with(diamonds, cor.test(price, x))
with(diamonds, cor.test(price, y))
with(diamonds, cor.test(price, z))

```

Note:
Create a scatterplot of price versus depth.

```{r scatterplot of price vs depth, echo=FALSE}
ggplot(aes(depth, price), data =diamonds) +
  geom_point()
```


Note:
Change the code to make the transparency of the points to be 1/100 of what they are now and mark
the x-axis every 2 units.

```{r, echo=FALSE}
ggplot(aes(depth, price), data =diamonds) +
  geom_point(aplha = 1/100) +
  scale_x_continuous(breaks=seq(0,80,2))
```


##### Most points are from 58 and 64.

Note:
What's correlation of depth vs price?

```{r, echo=FALSE}
with(diamonds, cor.test(price, depth))
```

##### Based on the correlation coefficient would you use depth to predict the price of a diamond?
##### No. Cause the there is no correlation.

Note:
Create a scatterplot of price vs carat
```{r, echo=FALSE}
ggplot(aes(carat, price), data = diamonds) +
  geom_point()
```

Note:
Create a scatterplot of price vs. volume (x * y * z).
This is a very rough approximation for a diamond's volume.
Create a new variable for volume in the diamonds data frame.

```{r, echo=FALSE}
diamonds$volume = diamonds$x * diamonds$y * diamonds$z
ggplot(aes(volume, price), data=diamonds) +
  geom_point()
```

Look at the outliers!

Note:
What's the correlation between price and volume?
Exclude diamonds that have a volume of 0 or that are greater or equal to 800.

```{r, echo=FALSE}
with(subset(diamonds, volume!=0 & volume <800), cor.test(volume, price))
```

Note:
Subset the data to exclude diamonds with a volume greater than or equal to 800. Also, exclude diamonds
with a volume of 0. Adjust the transparency of the points and add a linear model to the plot. 
Do you think this would be a useful mode to estimate the price of diamonds? Why or why not?
```{r, echo=FALSE}
ggplot(aes(volume, price),data = subset(diamonds, volume!=0 & volume <800)) +
  geom_point() +
  geom_smooth()
```

#####Does the linear model seems a good fit of data?
#####For volume <= 400, it seems it'a a good fit. But after that, it seems weired.

Use the function dplyr package to create a new data frame containing info on diamonds by clarity.
Name the data frame diamondsByClarity

The data frame should contain the following variables in this order.
       (1) mean_price
       (2) median_price
       (3) min_price
       (4) max_price
       (5) n

where n is the number of diamonds in each level of clarity.

```{r, echo=FALSE}
diamondsByClarity = group_by(diamonds, clarity) %>%
  summarise(
    mean_price = mean(price),
    median_price = median(price),
    min_price = min(price),
    max_price = max(price),
    n = n()) %>%
  arrange(clarity)

head(diamondsByClarity)

```


Note:
We've created summary data frames with the mean price by clarity and color. 

Your task is to write additional code to create two bar plots
on one output image using the grid.arrange() function from the package
gridExtra.

```{r, echo=FALSE}
diamonds_by_clarity = group_by(diamonds, clarity)
diamonds_mp_by_clarity = summarise(diamonds_by_clarity, mean_price = mean(price))

diamonds_by_color = group_by(diamonds, color)
diamonds_mp_by_color = summarise(diamonds_by_color, mean_price = mean(price))

p1 = ggplot(aes(x = clarity, y = mean_price), data = diamonds_mp_by_clarity) +
  geom_bar(stat = "identity")
p2 = ggplot(aes(x = color, y = mean_price), data = diamonds_mp_by_color) +
  geom_bar(stat = "identity")
library(gridExtra)
grid.arrange(p1, p2, ncol=1)

```


